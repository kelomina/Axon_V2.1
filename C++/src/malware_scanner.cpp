#include "malware_scanner.h"

#include "features.h"
#include "features_statistics.h"

#include <cmath>

namespace kvd {

static constexpr float PACKED_SECTIONS_RATIO_THRESHOLD = 0.4f;
static constexpr float PACKER_KEYWORD_HITS_THRESHOLD = 0.0f;

static std::vector<float> concat_features(const std::vector<float>& a, const std::vector<float>& b) {
  std::vector<float> out;
  out.reserve(a.size() + b.size());
  out.insert(out.end(), a.begin(), a.end());
  out.insert(out.end(), b.begin(), b.end());
  return out;
}

std::optional<MalwareScanner> MalwareScanner::create(const Config& config) {
  auto model_opt = LightGbmModel::load_from_file(config.model_path);
  if (!model_opt) {
    return std::nullopt;
  }

  MalwareScanner s;
  s.config_ = config;
  s.model_ = std::move(*model_opt);

  if (!config.model_normal_path.empty()) {
    s.model_normal_ = LightGbmModel::load_from_file(config.model_normal_path);
  }
  if (!config.model_packed_path.empty()) {
    s.model_packed_ = LightGbmModel::load_from_file(config.model_packed_path);
  }
  if (!config.family_classifier_json_path.empty()) {
    s.family_classifier_ = FamilyClassifier::load_from_json(config.family_classifier_json_path);
  }
  return s;
}

ScanResult MalwareScanner::scan_path(const std::string& path) const {
  ScanResult r;
  auto seq_opt = extract_byte_sequence_from_path(path, config_.max_file_size, config_.allowed_scan_root);
  if (!seq_opt) {
    r.error = "invalid_path_or_read_failed";
    return r;
  }

  std::vector<float> pe = extract_combined_pe_features_from_path(path, config_.allowed_scan_root);
  if (pe.empty()) {
    r.error = "pe_features_failed";
    return r;
  }

  std::vector<float> stats = extract_statistical_features(seq_opt->padded_sequence, seq_opt->original_length);
  std::vector<float> features = concat_features(stats, pe);

  const LightGbmModel* model_to_use = &model_;
  if (model_normal_ && model_packed_) {
    float packed_ratio = 0.0f;
    float packer_hits = 0.0f;
    auto idx_packed_ratio = pe_feature_index("packed_sections_ratio");
    auto idx_packer_hits = pe_feature_index("packer_keyword_hits_count");
    if (idx_packed_ratio && *idx_packed_ratio < pe.size()) packed_ratio = pe[*idx_packed_ratio];
    if (idx_packer_hits && *idx_packer_hits < pe.size()) packer_hits = pe[*idx_packer_hits];
    bool is_packed = (packed_ratio > PACKED_SECTIONS_RATIO_THRESHOLD) || (packer_hits > PACKER_KEYWORD_HITS_THRESHOLD);
    model_to_use = is_packed ? &(*model_packed_) : &(*model_normal_);
  }

  auto pred_opt = model_to_use->predict_one(features);
  if (!pred_opt) {
    r.error = "predict_failed";
    return r;
  }
  float score = *pred_opt;
  r.is_malware = score > config_.prediction_threshold;
  r.confidence = r.is_malware ? score : (1.0f - score);
  if (r.is_malware && family_classifier_) {
    auto fam = family_classifier_->predict(pe);
    if (fam) {
      r.family = *fam;
    }
  }
  return r;
}

ScanResult MalwareScanner::scan_bytes(const std::vector<std::uint8_t>& bytes) const {
  ScanResult r;
  if (bytes.empty()) {
    r.error = "empty_input";
    return r;
  }
  r.error = "scan_bytes_not_implemented";
  return r;
}

}
